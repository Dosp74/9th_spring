# WEEK 10 - 제이/한종서

## 핵심 키워드

### Spring Security

Spring Security는 인증(Authentication)과 인가(Authorization)를 필터 체인 기반으로 처리하는 보안 프레임워크이다.

여기서 인증은 **신원 확인**, 인가는 **권한 부여**를 의미한다.

Spring Security에서 가장 중요한 개념은 `Security Filter Chain`인데, Spring Security의 모든 것은 Filter에서 시작해서 Filter에서 끝난다.

HTTP 요청 -> [Security Filter Chain] -> Controller 순으로 필터 흐름이 진행되며, Filter Chain에는 Spring Security의 다양한 필터들이 속해 있다. 필요한 경우 개발자가 직접 커스텀 필터를 Filter Chain에 포함시킬 수 있다.

주요 필터로는 아이디/비밀번호 기반 인증 처리를 담당하는 `UsernamePasswordAuthenticationFilter`, HTTP 기본 인증 처리를 담당하는 `BasicAuthenticationFilter`, 인가 결정을 담당하는 `FilterSecurityInterceptor`가 있다.

주요 컴포넌트로는 사용자의 신원 정보를 담는 `Authentication`, 인증을 총괄하는 `AuthenticationManager`, DB에서 사용자 정보를 가져오는 `UserDetailsService`, 인증이 완료된 정보를 담아두는 `SecurityContextHolder`가 있다.

<br>

### 인증(Authentication)과 인가(Authorization)

인증은 시스템에 접근하려는 사용자가 본인이 주장하는 그 사람이 맞는지 확인하는 과정이다.

즉, 신원을 확인하는 과정이다.

아이디/비밀번호 로그인, 생체 인식(지문, Face ID), OTP 인증 등으로 신원을 확인하며 성공하면 시스템은 해당 사용자가 누구인지 알게 된다.

인증에 성공해야 인가 단계로 넘어갈 수 있다.

인가는 인증된 사용자가 특정 리소스에 접근하거나 특정 기능을 수행할 권한이 있는지 확인하는 과정이다.

예를 들어, 사용자가 관리자인지 일반 유저인지 역할을 확인할 수 있고, 역할을 확인한 후 해당 요청을 허용할지 거부할지 결정한다.

<br>

### 세션과 토큰

세션과 토큰은 인증된 사용자의 상태를 유지하기 위한 두 가지 핵심 방식을 의미한다.

로그인했다는 증거를 어디에 두는지에 대한 차이가 있으며 세션 방식은 서버가 누가 로그인했는지를 자신의 메모리나 DB에 직접 저장하고 관리하는 방식이다.

동작 원리는 다음과 같다.

1. 사용자가 로그인하면 서버는 세션 ID를 생성하여 서버 메모리에 저장한다.

2. 서버는 이 세션 ID를 브라우저에게 보내고, 브라우저는 이를 쿠키에 담아 보관한다.

3. 이후 사용자가 요청을 보낼 때마다 쿠키 속의 세션 ID를 함께 보낸다.

4. 서버는 세션 ID를 보관한 곳을 뒤져서 해당 세션 ID가 어떤 사용자인지 식별한다.

이 방식은 서버가 모든 제어권을 가져서 강제 로그아웃과 같은 조작을 하기 쉽다는 장점이 있으며, 사용자가 많아지면 서버 메모리 부담이 커진다는 단점이 있다. 또한 서버가 여러 대일 경우 세션 정보를 공유하기 위한 별도의 설정 등이 복잡해질 수 있다.

<br>

토큰 방식은 서버가 사용자를 기억하지 않는다. 대신 사용자에게 사용자 정보를 담은 암호화된 증명서 같은 것을 발급해준다.

동작 원리는 다음과 같다.

1. 사용자가 로그인하면 서버는 사용자 정보를 담은 토큰을 만들어 전달한다. 서버는 이 정보를 따로 저장하지 않는다.

2. 사용자는 이 토큰을 브라우저나 앱에 저장해두고, 요청할 때마다 헤더에 실어 보낸다.

3. 서버는 토큰이 자신이 발급한 것이 맞는지 서명을 확인하여 검증하고 바로 요청을 처리한다.

이 방식은 서버가 상태를 유지할 필요가 없어 가볍다는 장점이 있다. 즉 Stateless하다. 또한 서버가 여러 대여도 검증 방식만 같으면 되기 때문에 확장이 매우 쉬우며 모바일 앱과 연동하기도 좋다.

다만 토큰 자체는 데이터이므로 세션 ID보다 크기가 크고 한 번 발급된 토큰은 유효기간이 만료될 때까지 서버가 강제로 회수하기 어렵다는 단점이 있다.

<br>

### 액세스 토큰(Access Token)과 리프레시 토큰(Refresh Token)

Access Token은 API 요청 시마다 전달되는 출입증, Refresh Token은 Access Token이 만료되었을 때 새로 발급받기 위한 출입증 재발급권이라고 생각하면 편하다.

Access Token의 유효기간을 길게 가져갈 경우 탈취 시 위험하다는 단점이 있고, 짧게 가져갈 경우 로그인이 자주 풀려 UX가 나쁘다.

따라서 Access Token이 만료되었을 때 사용자 로그인 없이 새로운 Access Token을 발급받게 하는 것이 좋은데 이때 사용하는 것이 Refresh Token이다.

다음은 두 토큰이 움직이는 시나리오 예시이다.

1. 최초 로그인 시 사용자가 ID와 Password로 로그인하면, 서버는 두 종류의 토큰을 모두 발행하여 클라이언트에게 준다.

2. 클라이언트는 Access Token을 사용하여 서버와 통신한다.

3. Access Token의 유효기간이 지나 만료된다. 이후 서버는 401 UNAUTHORIZED 에러를 반환한다.

4. 클라이언트는 보관 중이던 Refresh Token을 서버의 토큰 재발급 엔드포인트로 보낸다.

5. 서버는 Refresh Token이 유효한지 DB에서 확인 후, 새로운 Access Token을 발급한다.

6. 사용자는 다시 로그인할 필요 없이 서비스를 계속 사용한다.

여기서 사용자는 토큰이 만료되었고, 다시 발급받았음을 모른 채 서비스를 사용할 수 있다.